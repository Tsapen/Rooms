// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rooms.proto

/*
Package main is a generated protocol buffer package.

It is generated from these files:
	rooms.proto

It has these top-level messages:
	Session
	Mess
	Nothing
*/
package main

import (
	fmt "fmt"
	"strconv"
	"strings"
	"sync"

	"context"
	"net"

	grpc "google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
)

type Room struct {
	mes   []Msg
	first int
	last  int
	users map[string]string
}

type Msg struct {
	author string
	info   string
}

type RS struct {
	space map[int]*Room
	mu    sync.Mutex
}

func StartServer(ctx context.Context, Addr string, num int) error {

	rs := RS{space: map[int]*Room{}}
	for i := 0; i < num; i++ {
		rs.space[i] = &Room{
			mes:   make([]Msg, 128, 128),
			users: map[string]string{},
		}

	}
	server := grpc.NewServer()
	lis, err := net.Listen("tcp", Addr)
	if err != nil {
		return err
	}
	go func() {
		RegisterRSServer(server, &rs)
		fmt.Println("starting server at :8081")
		server.Serve(lis)
	}()
	go func() {
		select {
		case <-ctx.Done():
			server.Stop()
		}
	}()
	return nil
}

func (rs RS) Subscribe(ctx context.Context, n *Nothing) (*Nothing, error) {
	nt := &Nothing{}
	MD, _ := metadata.FromIncomingContext(ctx)
	buf, _ := MD["roomname"]
	room, err := strconv.Atoi(buf[0])
	if err != nil {
		return nt, grpc.Errorf(codes.Unauthenticated, "room num isnt correct")
	}
	buf, _ = MD["username"]
	user := buf[0]
	buf, _ = MD["password"]
	pswd := buf[0]
	fmt.Println("Subscriber: " + strconv.Itoa(room) + ", " + user + ", " + pswd)
	rs.mu.Lock()
	defer rs.mu.Unlock()
	_, ok := rs.space[room]
	if !ok {
		return nt, grpc.Errorf(codes.Unauthenticated, "room doesnt exist")
	}
	if _, ok := rs.space[room].users[user]; ok {
		return nt, grpc.Errorf(codes.Unauthenticated, "user already added")
	}
	rs.space[room].users[user] = pswd
	return nt, nil
}

func (rs RS) Publish(stream RS_PublishServer) error {
	val, _ := stream.Recv()
	pars := strings.Split(val.Mess, "/")
	room, err := strconv.Atoi(pars[0])
	if err != nil {
		stream.Send(&Mess{strconv.Itoa(1)})
		return grpc.Errorf(codes.Unauthenticated, "room num isnt correct")
	}
	user := pars[1]
	pswd := pars[2]
	fmt.Println("Publisher:", pars)
	rs.mu.Lock()
	_, ok := rs.space[room]
	rs.mu.Unlock()
	if !ok {
		stream.Send(&Mess{strconv.Itoa(2)})
		return grpc.Errorf(codes.Unauthenticated, "room doesnt exist")
	}
	rs.mu.Lock()
	chpswd, ok := rs.space[room].users[user]
	rs.mu.Unlock()
	if !ok || chpswd != pswd {
		stream.Send(&Mess{strconv.Itoa(3)})
		return grpc.Errorf(codes.Unauthenticated, "user doesnt added")
	}
	stream.Send(&Mess{strconv.Itoa(0)})
	rs.mu.Lock()
	f := rs.space[room].first
	l := rs.space[room].last
	for l != f {
		txt := Mess{rs.space[room].mes[f].author + ": " + rs.space[room].mes[f].info}
		stream.Send(&txt)
		f = (f + 1) % 128
	}
	rs.mu.Unlock()
	stream.Send(&Mess{"--empty"})
	for {
		mes, err := stream.Recv()
		if err != nil {
			return err
		}
		if mes.Mess == "--end" {
			return nil
		}
		if len(mes.Mess) > 254 {
			continue
		}
		rs.mu.Lock()
		rs.space[room].mes[rs.space[room].last].author = user
		rs.space[room].mes[rs.space[room].last].info = mes.Mess
		rs.space[room].last = (rs.space[room].last + 1) % 128
		if rs.space[room].last == rs.space[room].first {
			rs.space[room].first = (rs.space[room].first + 1) % 128
		}
		rs.mu.Unlock()
	}

}
